//   Copyright 2016-2020 Jean-Francois Poilpret
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

/// @cond api

/**
 * @file
 * API to handle Real-Time Clock DS1307 I2C chip.
 */

#ifndef DS1307_H
#define DS1307_H

#include <fastarduino/array.h>
#include <fastarduino/i2c.h>
#include <fastarduino/future.h>
#include <fastarduino/utilities.h>
#include <fastarduino/new_i2c_handler.h>
#include <fastarduino/new_i2c_device.h>

// Device driver guidelines:
// - Template on MODE only if both modes accepted, otherwise force proper MODE
// - Define Future subclass (inside device class) for every future requiring input (constant, or user-provided)
//   naming convention: MethodNameFuture
// - Future subclass shall have explicit constructor with mandatory input arguments (no default)
// - define using types (inside device class) for each future subclass (UPPER_CASE same as METHOD_NAME)
// - each API method returns int (error code) and takes reference to specific future as unique argument

namespace devices
{
	/**
	 * Defines API for Real-Time Clock chips usage.
	 */
	namespace rtc
	{
	}
}

namespace devices::rtc
{
	/** Days of the week. */
	enum class WeekDay : uint8_t
	{
		SUNDAY = 1,
		MONDAY,
		TUESDAY,
		WEDNESDAY,
		THURSDAY,
		FRIDAY,
		SATURDAY
	};

	/**
	 * The datetime structure used by the RTC API.
	 * This is inspired by C standard time.h header but was slightly adapted to
	 * fit DS1307 RTC chip.
	 * @sa DS1307::get_datetime()
	 * @sa DS1307::set_datetime()
	 */
	struct tm
	{
		uint8_t tm_sec = 0;           /**< seconds after the minute - [ 0 to 59 ] */
		uint8_t tm_min = 0;           /**< minutes after the hour - [ 0 to 59 ] */
		uint8_t tm_hour = 0;          /**< hours since midnight - [ 0 to 23 ] */
		WeekDay tm_wday = WeekDay(0); /**< days since Sunday - [ 1 to 7 ] */
		uint8_t tm_mday = 0;          /**< day of the month - [ 1 to 31 ] */
		uint8_t tm_mon = 0;           /**< months since January - [ 1 to 12 ] */
		uint8_t tm_year = 0;          /**< years since 2000 */
	};

	/**
	 * The possible frequencies that can be generated by DS1307 RTC SQW/OUT pin.
	 * @sa DS1307::enable_output()
	 */
	enum class SquareWaveFrequency : uint8_t
	{
		FREQ_1HZ = 0x00,
		FREQ_4096HZ = 0x01,
		FREQ_8192HZ = 0x02,
		FREQ_32768HZ = 0x03
	};

	/**
	 * I2C device driver for the DS1307 RTC chip.
	 * Note that this chip only supports standard I2C mode (100 KHz).
	 */
	class DS1307 : public i2c::I2CDevice<i2c::I2CMode::STANDARD>
	{
		struct set_tm
		{
			uint8_t address_;
			tm tm_;
		};

	public:
		/**
		 * Create a new device driver for a DS1307 chip.
		 * @param manager reference to a suitable i2c::I2CManager for this device
		 */
		explicit DS1307(MANAGER& manager) : I2CDevice{manager, DEVICE_ADDRESS} {}

		/**
		 * Get the size of the additional RAM size of the chip.
		 */
		static constexpr uint8_t ram_size()
		{
			return RAM_SIZE;
		}

		// Asynchronous API
		//==================
		//TODO DOC
		class SetDatetimeFuture : public future::Future<void, set_tm>
		{
		public:
			explicit SetDatetimeFuture(const tm& datetime)
			{
				set_tm set;
				// 1st convert datetime for DS1307 (BCD)
				set.address_ = TIME_ADDRESS;
				set.tm_.tm_sec = utils::binary_to_bcd(datetime.tm_sec);
				set.tm_.tm_min = utils::binary_to_bcd(datetime.tm_min);
				set.tm_.tm_hour = utils::binary_to_bcd(datetime.tm_hour);
				set.tm_.tm_mday = utils::binary_to_bcd(datetime.tm_mday);
				set.tm_.tm_mon = utils::binary_to_bcd(datetime.tm_mon);
				set.tm_.tm_year = utils::binary_to_bcd(datetime.tm_year);
				this->reset_input(set);
			}
			SetDatetimeFuture(SetDatetimeFuture&&) = default;
			SetDatetimeFuture& operator=(SetDatetimeFuture&&) = default;
		};
		//TODO DOC
		using SET_DATETIME = SetDatetimeFuture;
		//TODO DOC
		int set_datetime(SET_DATETIME& future)
		{
			// send register address to write to (0)
			// send datetime at address 0
			return launch_commands(future, {write(i2c::I2CFinish::FORCE_STOP | i2c::I2CFinish::FUTURE_FINISH)});
		}

		//TODO DOC
		class GetDatetimeFuture : public future::Future<tm, uint8_t>
		{
		public:
			GetDatetimeFuture() : future::Future<tm, uint8_t>{TIME_ADDRESS} {}
			GetDatetimeFuture(GetDatetimeFuture&&) = default;
			GetDatetimeFuture& operator=(GetDatetimeFuture&&) = default;

			//TODO DOC
			bool get(tm& datetime)
			{
				if (!future::Future<tm, uint8_t>::get(datetime)) return false;
				// convert DS1307 output (BCD) to integer type
				datetime.tm_sec = utils::bcd_to_binary(datetime.tm_sec);
				datetime.tm_min = utils::bcd_to_binary(datetime.tm_min);
				datetime.tm_hour = utils::bcd_to_binary(datetime.tm_hour);
				datetime.tm_mday = utils::bcd_to_binary(datetime.tm_mday);
				datetime.tm_mon = utils::bcd_to_binary(datetime.tm_mon);
				datetime.tm_year = utils::bcd_to_binary(datetime.tm_year);
				return true;
			}
		};
		//TODO DOC
		using GET_DATETIME = GetDatetimeFuture;
		//TODO DOC
		int get_datetime(GET_DATETIME& future)
		{
			return launch_commands(future, {write(), read(i2c::I2CFinish::FORCE_STOP)});
		}

		//TODO DOC
		template<uint8_t SIZE_>
		class SetRamFuture : public future::Future<void, containers::array<uint8_t, SIZE_ + 1>>
		{
			using PARENT = future::Future<void, containers::array<uint8_t, SIZE_ + 1>>;
		public:
			SetRamFuture() = default;
			//TODO DOC
			explicit SetRamFuture(uint8_t address, const uint8_t (&data)[SIZE_])
			{
				static_assert(SIZE_ <= RAM_SIZE, "SIZE_ template paraneter must be less than RAM_SIZE!");
				typename PARENT::IN input;
				input[0] = static_cast<uint8_t>(address + RAM_START);
				input.set(uint8_t(1), data);
				this->reset_input(input);
			}
			SetRamFuture(SetRamFuture<SIZE_>&&) = default;
			SetRamFuture& operator=(SetRamFuture<SIZE_>&&) = default;

			bool is_input_valid() const
			{
				return (this->get_input()[0] + SIZE_ <= RAM_END);
			}
		};
		//TODO DOC
		template<uint8_t SIZE> using SET_RAM = SetRamFuture<SIZE>;
		//TODO DOC
		template<uint8_t SIZE> int set_ram(SET_RAM<SIZE>& future)
		{
			if (!future.is_input_valid())
				return errors::EINVAL;
			return launch_commands(future, {write(i2c::I2CFinish::FORCE_STOP | i2c::I2CFinish::FUTURE_FINISH)});
		}

		//TODO DOC
		class SetRam1Future : public future::Future<void, containers::array<uint8_t, 2>>
		{
			using PARENT = future::Future<void, containers::array<uint8_t, 2>>;
		public:
			SetRam1Future() = default;
			//TODO DOC
			explicit SetRam1Future(uint8_t address, uint8_t data)
				:	PARENT{{static_cast<uint8_t>(address + RAM_START), data}} {}
			SetRam1Future(SetRam1Future&&) = default;
			SetRam1Future& operator=(SetRam1Future&&) = default;

			bool is_input_valid() const
			{
				return (this->get_input()[0] < RAM_END);
			}
		};
		//TODO DOC
		using SET_RAM1 = SetRam1Future;
		//TODO DOC
		int set_ram(SET_RAM1& future)
		{
			if (!future.is_input_valid())
				return errors::EINVAL;
			return launch_commands(future, {write(i2c::I2CFinish::FORCE_STOP | i2c::I2CFinish::FUTURE_FINISH)});
		}

		//TODO DOC
		template<uint8_t SIZE_>
		class GetRamFuture : public future::Future<containers::array<uint8_t, SIZE_>, uint8_t>
		{
			using PARENT = future::Future<containers::array<uint8_t, SIZE_>, uint8_t>;
		public:
			//TODO DOC
			explicit GetRamFuture(uint8_t address) : PARENT{static_cast<uint8_t>(address + RAM_START)}
			{
				static_assert(SIZE_ <= RAM_SIZE, "SIZE_ template paraneter must be less than RAM_SIZE!");
			}
			GetRamFuture(GetRamFuture<SIZE_>&&) = default;
			GetRamFuture& operator=(GetRamFuture<SIZE_>&&) = default;

			bool is_input_valid() const
			{
				return (this->get_input() + SIZE_ <= RAM_END);
			}
		};
		//TODO DOC
		template<uint8_t SIZE> using GET_RAM = GetRamFuture<SIZE>;
		//TODO DOC
		template<uint8_t SIZE> int get_ram(GET_RAM<SIZE>& future)
		{
			if (!future.is_input_valid())
				return errors::EINVAL;
			return launch_commands(future, {write(), read(i2c::I2CFinish::FORCE_STOP)});
		}

		//TODO DOC
		class GetRam1Future : public future::Future<uint8_t, uint8_t>
		{
			using PARENT = future::Future<uint8_t, uint8_t>;
		public:
			//TODO DOC
			explicit GetRam1Future(uint8_t address = 0) : PARENT{static_cast<uint8_t>(address + RAM_START)} {}
			GetRam1Future(GetRam1Future&&) = default;
			GetRam1Future& operator=(GetRam1Future&&) = default;

			bool is_input_valid() const
			{
				return this->get_input() < RAM_END;
			}
		};
		//TODO DOC
		using GET_RAM1 = GetRam1Future;
		//TODO DOC
		int get_ram(GET_RAM1& future)
		{
			if (!future.is_input_valid())
				return errors::EINVAL;
			return launch_commands(future, {write(), read(i2c::I2CFinish::FORCE_STOP)});
		}

		//TODO DOC
		class HaltClockFuture : public future::Future<void, containers::array<uint8_t, 2>>
		{
		public:
			// just write 0x80 at address 0
			HaltClockFuture() : future::Future<void, containers::array<uint8_t, 2>>{{TIME_ADDRESS, CLOCK_HALT}} {}
			HaltClockFuture(HaltClockFuture&&) = default;
			HaltClockFuture& operator=(HaltClockFuture&&) = default;
		};
		//TODO DOC
		using HALT_CLOCK = HaltClockFuture;
		//TODO DOC
		int halt_clock(HALT_CLOCK& future)
		{
			return launch_commands(future, {write(i2c::I2CFinish::FORCE_STOP | i2c::I2CFinish::FUTURE_FINISH)});
		}

		//TODO DOC
		class EnableOutputFuture : public future::Future<void, containers::array<uint8_t, 2>>
		{
			using PARENT = future::Future<void, containers::array<uint8_t, 2>>;
		public:
			//TODO DOC
			explicit EnableOutputFuture(SquareWaveFrequency frequency)
			{
				ControlRegister control;
				control.sqwe = 1;
				control.rs = uint8_t(frequency);
				typename PARENT::IN input;
				input[0] = CONTROL_ADDRESS;
				input[1] = control.data;
				this->reset_input(input);
			}
			EnableOutputFuture(EnableOutputFuture&&) = default;
			EnableOutputFuture& operator=(EnableOutputFuture&&) = default;
		};
		//TODO DOC
		using ENABLE_OUTPUT = EnableOutputFuture;
		//TODO DOC
		int enable_output(ENABLE_OUTPUT& future)
		{
			return launch_commands(future, {write(i2c::I2CFinish::FORCE_STOP | i2c::I2CFinish::FUTURE_FINISH)});
		}

		//TODO DOC
		class DisableOutputFuture : public future::Future<void, containers::array<uint8_t, 2>>
		{
			using PARENT = future::Future<void, containers::array<uint8_t, 2>>;
		public:
			//TODO DOC
			explicit DisableOutputFuture(bool output_value)
			{
				ControlRegister control;
				control.out = output_value;
				typename PARENT::IN input;
				input[0] = CONTROL_ADDRESS;
				input[1] = control.data;
				this->reset_input(input);
			}
			DisableOutputFuture(DisableOutputFuture&&) = default;
			DisableOutputFuture& operator=(DisableOutputFuture&&) = default;
		};
		//TODO DOC
		using DISABLE_OUTPUT = DisableOutputFuture;
		//TODO DOC
		int disable_output(DISABLE_OUTPUT& future)
		{
			return launch_commands(future, {write(i2c::I2CFinish::FORCE_STOP | i2c::I2CFinish::FUTURE_FINISH)});
		}

		// Synchronous API
		//=================
		/**
		 * Change date and time of the RTC chip connected to this driver.
		 * @warning Blocking API!
		 * 
		 * @param datetime the new date/time to set on the RTC chip; all values 
		 * must be properly set and be correct, in particular, note that
		 * `tm::tm_wday` must be set correctly by yourself (the RTC chip does not
		 * calculate it itself).
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * shall be called for further information on the error.
		 */
		bool set_datetime(const tm& datetime)
		{
			SET_DATETIME future{datetime};
			if (set_datetime(future) != 0) return false;
			return (future.await() == future::FutureStatus::READY);
		}

		/**
		 * Get the current date and time from the RTC chip.
		 * @warning Blocking API!
		 * 
		 * @param datetime a reference to a `tm` variable that will be filled with
		 * current date and time from the RTC chip
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * shall be called for further information on the error.
		 */
		bool get_datetime(tm& datetime)
		{
			GET_DATETIME future;
			if (get_datetime(future) != 0) return false;
			return future.get(datetime);
		}

		/**
		 * Disable the RTC oscillator, hence the time will not be updated anymore.
		 * If you want to re-enable the clock, you need to set a new date/time
		 * with `set_datetime()`.
		 * @warning Blocking API!
		 * 
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * @sa set_datetime()
		 */
		bool halt_clock()
		{
			HALT_CLOCK future;
			if (halt_clock(future) != 0) return false;
			return (future.await() == future::FutureStatus::READY);
		}

		/**
		 * Enable square wave output to the SQW/OUT pin of the RTC chip.
		 * @warning Blocking API!
		 * 
		 * @param frequency one of the supported RTC frequencies, defined in
		 * `SquareWaveFrequency` enum
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * @sa disable_output()
		 */
		bool enable_output(SquareWaveFrequency frequency = SquareWaveFrequency::FREQ_1HZ)
		{
			ENABLE_OUTPUT future{frequency};
			if (enable_output(future) != 0) return false;
			return (future.await() == future::FutureStatus::READY);
		}

		/**
		 * Disable square wave output to the SQW/OUT pin of the RTC chip.
		 * @warning Blocking API!
		 * 
		 * @param output_value TODO
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * @sa enable_output()
		 */
		bool disable_output(bool output_value = false)
		{
			DISABLE_OUTPUT future{output_value};
			if (disable_output(future) != 0) return false;
			return (future.await() == future::FutureStatus::READY);
		}

		/**
		 * Set one cell of the chip internal RAM to the specified value.
		 * @warning Blocking API!
		 * 
		 * @param address the address of the cell to write, must be between
		 * `0` and `ram_size()`.
		 * @param data the value to put at @p address
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * @sa get_ram(uint8_t)
		 */
		bool set_ram(uint8_t address, uint8_t data)
		{
			SET_RAM1 future{address, data};
			if (set_ram(future) != 0) return false;
			return (future.await() == future::FutureStatus::READY);
		}

		/**
		 * Get the value of one cell of the chip internal RAM.
		 * @warning Blocking API!
		 * 
		 * @param address the address of the cell to read, must be between
		 * `0` and `ram_size()`.
		 * @return the value read at @p address
		 * @sa set_ram(uint8_t, uint8_t)
		 */
		uint8_t get_ram(uint8_t address)
		{
			GET_RAM1 future{address};
			if (get_ram(future) != 0) return false;
			uint8_t data = 0;
			future.get(data);
			return data;
		}

		/**
		 * Set several cells of the chip internal RAM to specified values.
		 * @warning Blocking API!
		 * 
		 * @tparam SIZE the number of bytes to be written; `address + SIZE` must be
		 * less than `ram_size()`.
		 * @param address the address of the first cell to write, must be between
		 * `0` and `ram_size()`.
		 * @param data pointer to a buffer containing the values to write
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * @sa get_ram(uint8_t, uint8_t(&)[])
		 */
		template<uint8_t SIZE> bool set_ram(uint8_t address, const uint8_t (&data)[SIZE])
		{
			SET_RAM<SIZE> future{address, data};
			if (set_ram(future) != 0) return false;
			return (future.await() == future::FutureStatus::READY);
		}

		/**
		 * Get values of several cells from the chip internal RAM.
		 * @warning Blocking API!
		 * 
		 * @tparam SIZE the number of bytes to read; `address + SIZE` must be
		 * less than `ram_size()`.
		 * @param address the address of the first cell to read, must be between
		 * `0` and `ram_size()`.
		 * @param data pointer to a buffer where read values will be copied
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * @sa set_ram(uint8_t, const uint8_t(&)[])
		 */
		template<uint8_t SIZE> bool get_ram(uint8_t address, uint8_t (&data)[SIZE])
		{
			GET_RAM<SIZE> future{address};
			if (get_ram(future) != 0) return false;
			typename GET_RAM<SIZE>::OUT temp;
			if (!future.get(temp)) return false;
			memcpy(data, temp.data(), SIZE);
			return true;
		}

		/**
		 * Write any type of data to the chip internal RAM.
		 * @warning Blocking API!
		 * 
		 * @tparam T the type of data to be written
		 * @param address the address where to write data, must be between
		 * `0` and `ram_size() - sizeof(T)`.
		 * @param data the actual data of type @p T, to be written
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * @sa get_ram(uint8_t, T&)
		 */
		template<typename T> bool set_ram(uint8_t address, const T& data)
		{
			uint8_t temp[sizeof(T)];
			utils::as_array<T>(data, temp);
			SET_RAM<sizeof(T)> future{address, temp};
			if (set_ram(future) != 0) return false;
			return (future.await() == future::FutureStatus::READY);
		}

		/**
		 * Read any type of data from the chip internal RAM.
		 * Note that this method only copies bytes to a variable of some type, no
		 * constructor will be called; hence, it is preferrable to use only simple
		 * struct types.
		 * @warning Blocking API!
		 * 
		 * @tparam T the type of data to be read
		 * @param address the address where to find data to read, must be between
		 * `0` and `ram_size() - sizeof(T)`.
		 * @param data a reference to a variable that will be copied the read content
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * @sa set_ram(uint8_t, const T&)
		 */
		template<typename T> bool get_ram(uint8_t address, T& data)
		{
			GET_RAM<sizeof(T)> future{address};
			if (get_ram(future) != 0) return false;
			return future.get(reinterpret_cast<uint8_t&>(data));
		}

	private:
		static constexpr const uint8_t DEVICE_ADDRESS = 0x68 << 1;
		static constexpr const uint8_t RAM_START = 0x08;
		static constexpr const uint8_t RAM_END = 0x40;
		static constexpr const uint8_t RAM_SIZE = RAM_END - RAM_START;
		static constexpr const uint8_t TIME_ADDRESS = 0x00;
		static constexpr const uint8_t CLOCK_HALT = 0x80;
		static constexpr const uint8_t CONTROL_ADDRESS = 0x07;

		union ControlRegister
		{
			explicit ControlRegister(uint8_t data = 0) : data{data} {}

			uint8_t data;
			struct
			{
				uint8_t rs : 2;
				uint8_t res1 : 2;
				uint8_t sqwe : 1;
				uint8_t res2 : 2;
				uint8_t out : 1;
			};
		};
	};
}

#endif /* DS1307_H */
/// @endcond
