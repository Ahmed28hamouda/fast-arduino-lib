<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FastArduino: Adding support for an I2C device</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FastArduino
   </div>
   <div id="projectbrief">C++ library to build fast but small Arduino/AVR projects</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('i2cdevices.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Adding support for an I2C device </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__home_jfpoilpret_electronics_fast-arduino-lib_dox_i2c-devices"></a></p>
<p>TODO rework to fit new API There are plenty of devices of all kinds, based on I2C interface, that you may want to connect to your Arduino or a board you created with an AVR ATmega or ATtiny MCU.</p>
<p>If you want to learn more about I2C concepts and vocabulary, you can find further information on <a href="https://en.wikipedia.org/wiki/I%C2%B2C">Wikipedia</a>.</p>
<p>Unfortunately, FastArduino obviously cannot provide specific support for all existing I2C devices.</p>
<p>However, based on a given device datasheet, it can be quite easy to add a FastArduino driver for any I2C device.</p>
<p>FastArduino provides all the necessary classes and methods for you to implement such a specific driver.</p>
<p>The following sections describe the FastArduino API for I2C device driver implementation, and list the steps to successfully implement such a driver.</p>
<h1>FastArduino I2C driver API </h1>
<p>The generic support for I2C device driver in FastArduino looks quite simple, it is entirely embedded in 1 class, <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code>; this is a template class which all actual I2C device drivers shall derive from.</p>
<p>This template class has only one <code>MODE</code> parameter, of type <code><a class="el" href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36" title="I2C available transmission modes.">i2c::I2CMode</a></code>, which defines the I2C bus speed, among two supported speeds: Normal (100KHz) or Fast (400KHz).</p>
<p>The <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code> class mainly contains <code>protected</code> methods to read and write content to a device on the I2C bus.</p>
<p>As you can see in the following diagrams, the drivers for I2C devices currently supported by FastArduino directly derive from <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code>:</p>
<ol type="1">
<li>DS1307 Real Time Clock chip <div class="image">
<img src="classdevices_1_1rtc_1_1_d_s1307__inherit__graph.png" alt=""/>
</div>
 </li>
<li>MCP23017 16-Bit I/O Expander chip <div class="image">
<img src="classdevices_1_1mcp23017_1_1_m_c_p23017__inherit__graph.png" alt=""/>
</div>
 </li>
<li>MPU6050 3D Accelerometer-Gyroscope chip <div class="image">
<img src="classdevices_1_1magneto_1_1_m_p_u6050__inherit__graph.png" alt=""/>
</div>
 </li>
<li>HMC5883L 3D Compass chip <div class="image">
<img src="classdevices_1_1magneto_1_1_h_m_c5883_l__inherit__graph.png" alt=""/>
</div>
 </li>
</ol>
<p>Do note that, for the RTC DS1307 device above, <code>MODE</code> template parameter has been forced to <code>i2c::I2CMode::STANDARD</code> because that device does not support Fast I2C mode. Driver classes for other devices are still template with <code><a class="el" href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36" title="I2C available transmission modes.">i2c::I2CMode</a></code> template parameter as they can be used in any mode.</p>
<p>Creating a new driver for an I2C device is as simple as:</p><ol type="1">
<li>Creating a <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code> subclass; let's call it <code>MyI2CDevice</code> in the rest of this page.</li>
<li>Add a constructor with one argument: <code>MyI2CDevice::MyI2CDevice(MANAGER&amp; manager)</code> where <code>MANAGER</code> is directly defined as <code>i2c::I2CManager&lt;MODE&gt;</code> in superclass <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code>.</li>
<li>Add proper <code>public</code> API on this <code>MyI2CDevice</code> class, based on actual device features we want to use.</li>
<li>Implement this API through the basic <code>protected</code> API methods inherited from <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code></li>
</ol>
<h2>I2CDevice API</h2>
<p>Subclassing <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code> gives <code>MyI2CDevice</code> access to all low-level <code>protected</code> methods:</p><ul>
<li><code>i2c::I2CDevice.read(uint8_t, uint8_t*, uint8_t, BusConditions)</code>: read an array of bytes from the I2C device</li>
<li><code>i2c::I2CDevice.read(uint8_t, T&amp;, BusConditions)</code>: read bytes as a struct <code>T</code> from the I2C device</li>
<li><code>i2c::I2CDevice.write(uint8_t, uint8_t, BusConditions)</code>: write one byte to the I2C device</li>
<li><code>i2c::I2CDevice.write(uint8_t, const uint8_t*, uint8_t, BusConditions)</code>: write an array of bytes to the I2C device</li>
<li><code>i2c::I2CDevice.write(uint8_t, const T&amp;, BusConditions)</code>: write bytes of a struct <code>T</code> to the I2C device</li>
</ul>
<p>All methods above start with <code>uint8_t address</code> as their first argument. This is the unique device address on the I2C bus, made of 7 bits. Typically an I2C device falls in one of the following categories:</p><ol type="1">
<li>it has a fixed I2C address that cannot be changed (e.g. DS1307 RTC chip)</li>
<li>it has an I2C address that can be changed by hardware (e.g. jumpers) among a limited range of possible addresses (e.g. MCP23017 I/O expander chip, MPU 6050 acceleromete/gyroscope chip)</li>
<li>it has a fixed I2C address that can be changed by software (e.g. VL53L0X "micro lidar" chip); this is generally harder to support.</li>
</ol>
<p>For devices in category 1, you would typically define the address as a constant in <code>MyI2CDevice</code>.</p>
<p>For devices in category 2, you would rather define an <code>enum class</code> limiting the possible addresses configurable by hardware, or pass the address (as <code>uint8_t</code>) to the driver class constructor.</p>
<p>For devices in category 3, you would first define the fixed address as a constant, then define an API to change it (as a data member of <code>MyI2CDevice</code>).</p>
<p>All methods above always end with a <code>i2c::BusConditions conditions</code> argument. This argument is super important as it defines how each method shall handle the I2C bus (this bus is shared between all devices and thus access to it must follow certain rules).</p>
<p>In particular, before any access to the I2C bus, a host device (the MCU) must first send a "START condition" onto it, and only after that can it initialize a communication to a given device, known by its I2C address.</p>
<p>All bytes sent or received must be acknowledged (though special signals on SDA and SCL wires) by the recipient.</p>
<p>Once a transmission between a host and a device is finished, the bus must be released (for later transmissions) through a "STOP condition".</p>
<p>The <code>i2c::BusConditions</code> argument for each read/write method indicates whether te method should first acquire the I2C bus before writing or reading, if it should release the I2C bus after writing or reading. This allows your API implementation to perform a sequence of calls to the I2C device, where the first call will acquire the bus and the last call will release it, and calls in between will not need to acquire or release the bus.</p>
<p>Note that many I2C devices communication is based on writing and reading "registers", each device having its own list of specific registers. Hence most I2C device drivers API will consist in reading or writing one register. In FastArduino, drivers like <code><a class="el" href="classdevices_1_1magneto_1_1_h_m_c5883_l.html" title="I2C device driver for the HMC5883L compass chip.">devices::magneto::HMC5883L</a></code> first define <code>private</code> methods to read and write registers, which other API methods can simply use (by passing the right register number and proper value):</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> BUSCOND = i2c::BusConditions;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> write_register(uint8_t address, uint8_t value)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="namespacei2c_1_1_status.html#a64da02c9095e825b16389e29f86d4192">i2c::Status::OK</a>;</div>
<div class="line">    <span class="keywordflow">return</span> (this-&gt;write(DEVICE_ADDRESS, address, BUSCOND::START_NO_STOP) == <a class="code" href="namespacei2c_1_1_status.html#a64da02c9095e825b16389e29f86d4192">OK</a></div>
<div class="line">            &amp;&amp; this-&gt;write(DEVICE_ADDRESS, value, BUSCOND::NO_START_STOP) == <a class="code" href="namespacei2c_1_1_status.html#a64da02c9095e825b16389e29f86d4192">OK</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> read_register(uint8_t address, uint8_t&amp; value)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="namespacei2c_1_1_status.html#a64da02c9095e825b16389e29f86d4192">i2c::Status::OK</a>;</div>
<div class="line">    <span class="keywordflow">return</span> (this-&gt;write(DEVICE_ADDRESS, address, BUSCOND::START_NO_STOP) == <a class="code" href="namespacei2c_1_1_status.html#a64da02c9095e825b16389e29f86d4192">OK</a></div>
<div class="line">            &amp;&amp; this-&gt;read(DEVICE_ADDRESS, value, BUSCOND::REPEAT_START_STOP) == <a class="code" href="namespacei2c_1_1_status.html#a64da02c9095e825b16389e29f86d4192">OK</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note usage of <code>using BUSCOND = i2c::BusConditions;</code> and <code>using <a class="el" href="namespacei2c_1_1_status.html#a64da02c9095e825b16389e29f86d4192" title="Code indicating the last called method executed as expected without any issue.">i2c::Status::OK</a>;</code> to ease code writing and reading.</p>
<p>In this snippet, <code>write_register()</code> is straightforward:</p><ol type="1">
<li>It starts (<code>START_NO_STOP</code>) I2C communication with device <code>DEVICE_ADDRESS</code> and sends register number <code>address</code> to the I2C device</li>
<li>It then sends <code>value</code> byte to the same device (as part of the same transmission) which will be written to the device register, then it stops (<code>NO_START_STOP</code>) I2C communication</li>
</ol>
<p><code>read_register()</code> is a bit more special:</p><ol type="1">
<li>It starts (<code>START_NO_STOP</code>) I2C communication with device <code>DEVICE_ADDRESS</code> and sends register number <code>address</code> to the I2C device (same as before)</li>
<li>It then restarts (<code>REPEAT_START_STOP</code>) a new I2C transmission to ask the device for the value in that register, then it finally stops (<code>REPEAT_START_STOP</code>) I2C communication</li>
</ol>
<p>Here, in step 2, we cannot use the same transmission to read after write, as one transmission defines the data direction; however, we can take advantage of the current write transmission (I2C bus already accquired) to restart a new transmission but for reading. Please do note that some I2C devices do support this way for write-then-read, but not all of them; refer to the target device datahseet for further details.</p>
<p>Note that both <code><a class="el" href="classi2c_1_1_i2_c_device.html#a788c6ee190552796b171c7c1d45548ec" title="Build a read I2CLightCommand that can be later pushed to the I2C Manager for proper handling.">i2c::I2CDevice.read()</a></code> and <code><a class="el" href="classi2c_1_1_i2_c_device.html#ada1d513b26e28281b64ca8cc97c39f8d" title="Build a write I2CLightCommand that can be later pushed to the I2C Manager for proper handling.">i2c::I2CDevice.write()</a></code> sets of methods exist in a <code>template</code> flavour that allows using <code>struct</code> types references directly, instead of using arrays of bytes, which can simplify code implementation.</p>
<h1>Debugging support for a new device (low-level) </h1>
<p>In general, before developing a full-fledged driver for an I2C device, you need to learn how to use that device.</p>
<p>Based on the device datasheet, you first learn how to manipulate the device through the I2C bus.</p>
<p>For better understanding, you generally use a debugging example that helps demonstrate how the device works.</p>
<p>One easy way to develop such a debugging sample is to create a program with just one source code file containing:</p><ul>
<li>proper <code>#include</code> directives</li>
<li>a <code>PublicDevice</code> class that derives from <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code> but declares <code>main()</code> as a <code>friend</code>, which allows direct calls, from <code>main()</code>, to <code>protected</code> API of <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code>, for easy testing</li>
<li>directly call SPI API on a <code>PublicDevice</code> instance, from <code>main()</code> and trace results to a console, through UART</li>
</ul>
<p>FastArduino includes such a debugging sample in <code>examples/i2c/I2CDeviceProto</code> example, copied hereafter:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//   Copyright 2016-2020 Jean-Francois Poilpret</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">//   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">//   you may not use this file except in compliance with the License.</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">//   You may obtain a copy of the License at</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//       http://www.apache.org/licenses/LICENSE-2.0</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">//   Unless required by applicable law or agreed to in writing, software</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">//   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">//   See the License for the specific language governing permissions and</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">//   limitations under the License.</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160; </div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">/*</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment"> * This is a skeleton program to help connect, debug and understand how a given</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment"> * I2C device (not already supported by FastArduino) works.</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment"> * That helps creating a new specific support API for that device for reuse in </span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment"> * other programs and potential integration to FastArduino project.</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment"> * To ease wiring and debugging, I suggest using a real Arduino board (I typically </span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment"> * use UNO) and a small breadboard for connecting the I2C device.</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment"> * </span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment"> * Wiring:</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment"> * NB: you should add pullup resistors (10K-22K typically) on both SDA and SCL lines.</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment"> * - on Arduino UNO:</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment"> *   - A4 (PC4, SDA): connected to I2C SDA pin</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment"> *   - A5 (PC5, SCL): connected to I2C SCL pin</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment"> *   - direct USB access (traces output)</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160; </div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="time_8h.html">fastarduino/time.h</a>&gt;</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="i2c__device_8h.html">fastarduino/i2c_device.h</a>&gt;</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="utilities_8h.html">fastarduino/utilities.h</a>&gt;</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="uart_8h.html">fastarduino/uart.h</a>&gt;</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="i2c__debug_8h.html">fastarduino/i2c_debug.h</a>&gt;</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="i2c__status_8h.html">fastarduino/i2c_status.h</a>&gt;</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160; </div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">// This macro determines if extensive debug traces should be sent (recommended during first attempts)</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="preprocessor">#define DEBUG_I2C</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160; </div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="comment">// I2C Device specific constants go here</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment">//======================================</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> <a class="code" href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36">i2c::I2CMode</a> MODE = <a class="code" href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36a94e94133f4bdc1794c6b647b8ea134d0">i2c::I2CMode::FAST</a>;</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> uint8_t DEVICE_ADDRESS = 0x68 &lt;&lt; 1;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160; </div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="preprocessor">#ifdef DEBUG_I2C</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> uint8_t DEBUG_SIZE = 32;</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="keyword">using</span> DEBUGGER = <a class="code" href="classi2c_1_1debug_1_1_i2_c_debug_status_recorder.html">i2c::debug::I2CDebugStatusRecorder&lt;DEBUG_SIZE, DEBUG_SIZE&gt;</a>;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="keyword">using</span> MANAGER = <a class="code" href="classi2c_1_1_i2_c_sync_status_debug_manager.html">i2c::I2CSyncStatusDebugManager&lt;MODE, DEBUGGER&amp;, DEBUGGER&amp;&gt;</a>;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="preprocessor">#define DEBUG(OUT) debugger.trace(OUT)</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="keyword">using</span> <a class="code" href="namespacei2c_1_1status.html#a8e07f8d34f9f155ed73d199716ec173f">STATUS</a> = <a class="code" href="classi2c_1_1status_1_1_i2_c_latest_status_holder.html">i2c::status::I2CLatestStatusHolder</a>;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="keyword">using</span> MANAGER = <a class="code" href="classi2c_1_1_i2_c_sync_status_manager.html">i2c::I2CSyncStatusManager&lt;MODE, STATUS&amp;&gt;</a>;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="preprocessor">#define DEBUG(OUT) OUT &lt;&lt; streams::hex &lt;&lt; status_holder.latest_status() &lt;&lt; streams::endl</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160; </div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment">// Define vectors we need in the example</span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<a class="code" href="uart_8h.html#aa33c57bb6fa1e93177abb21fe8fecb10">REGISTER_UATX_ISR</a>(0)</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160; </div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment">// UART for traces</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;static constexpr const uint8_t OUTPUT_BUFFER_SIZE = 64;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;static <span class="keywordtype">char</span> output_buffer[OUTPUT_BUFFER_SIZE];</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;static <a class="code" href="namespaceserial.html">serial</a>::hard::UATX&lt;<a class="code" href="namespaceboard.html">board</a>::<a class="code" href="namespaceboard.html#a8541ca1f10a050c4356d6ccd76d9a907">USART</a>::USART0&gt; uart{output_buffer};</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="keyword">static</span> <a class="code" href="classstreams_1_1ostream.html">streams::ostream</a> out = uart.out();</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160; </div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment">// The following type aliases will be useful for declaring proper Futures and calling I2CDevice API</span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="keyword">using</span> PARENT = <a class="code" href="classi2c_1_1_i2_c_device.html">i2c::I2CDevice&lt;MANAGER&gt;</a>;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> PROXY = <span class="keyword">typename</span> PARENT::template PROXY&lt;T&gt;;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> OUT, <span class="keyword">typename</span> IN&gt; <span class="keyword">using</span> FUTURE = <span class="keyword">typename</span> PARENT::template FUTURE&lt;OUT, IN&gt;;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160; </div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="comment">// Subclass I2CDevice to make protected methods available</span></div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="keyword">class </span>PublicDevice: <span class="keyword">public</span> PARENT</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;{</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="keyword">public</span>:</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    PublicDevice(MANAGER&amp; manager): PARENT{manager, DEVICE_ADDRESS, i2c::Mode&lt;MODE&gt;{}} {}</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <span class="keyword">friend</span> <span class="keywordtype">int</span> main();</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;};</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160; </div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="keyword">using</span> <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">streams::endl</a>;</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="keyword">using</span> <a class="code" href="namespacestreams.html#adaf650921b3a5d448f8aac51dba924d2">streams::dec</a>;</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="keyword">using</span> <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">streams::hex</a>;</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160; </div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;{</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    sei();</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    </div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    uart.begin(115200);</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    out.<a class="code" href="classstreams_1_1ios__base.html#a46cf9813c05c34ff93d8ff19eff1ea9f">width</a>(2);</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    </div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="comment">// Start TWI interface</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <span class="comment">//====================</span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="preprocessor">#ifdef DEBUG_I2C</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    DEBUGGER debugger;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    MANAGER manager{debugger, debugger};</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="preprocessor">#else</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <a class="code" href="namespacei2c_1_1status.html#a8e07f8d34f9f155ed73d199716ec173f">STATUS</a> status_holder;</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    MANAGER manager{status_holder};</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    manager.begin();</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;I2C interface started&quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    </div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    PublicDevice device{manager};</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    </div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <span class="comment">// Init I2C device if needed</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160; </div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="comment">// Output all debug traces</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <a class="code" href="namespacei2c_1_1debug.html#aa73d62f49bbf5a9cd8ced80e467cefcc">DEBUG</a>(out);</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    </div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="comment">// Loop to show measures</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    {</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        <span class="comment">// Read measures and display them to UART</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160; </div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        <span class="comment">// Output all debug traces</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <a class="code" href="namespacei2c_1_1debug.html#aa73d62f49bbf5a9cd8ced80e467cefcc">DEBUG</a>(out);</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160; </div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        <a class="code" href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a>(1000);</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    }</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    </div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <span class="comment">// Stop TWI interface</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    <span class="comment">//===================</span></div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    manager.end();</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;End&quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;}</div>
</div><!-- fragment --><p>This example is just an empty skeleton for your own tests. It is made of several parts:</p>
 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="time_8h.html">fastarduino/time.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="i2c__device_8h.html">fastarduino/i2c_device.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="utilities_8h.html">fastarduino/utilities.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uart_8h.html">fastarduino/uart.h</a>&gt;</span></div>
</div><!-- fragment --><p> Those lines include a few headers necessary (or just useful) to debug an I2C device.</p>
<div class="fragment"><div class="line"><a class="code" href="uart_8h.html#aa33c57bb6fa1e93177abb21fe8fecb10">REGISTER_UATX_ISR</a>(0)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// UART for traces</span></div>
<div class="line">static constexpr const uint8_t OUTPUT_BUFFER_SIZE = 64;</div>
<div class="line">static <span class="keywordtype">char</span> output_buffer[OUTPUT_BUFFER_SIZE];</div>
<div class="line">static <a class="code" href="namespaceserial.html">serial</a>::hard::UATX&lt;<a class="code" href="namespaceboard.html">board</a>::<a class="code" href="namespaceboard.html#a8541ca1f10a050c4356d6ccd76d9a907">USART</a>::USART0&gt; uart{output_buffer};</div>
<div class="line"><span class="keyword">static</span> <a class="code" href="classstreams_1_1ostream.html">streams::ostream</a> out = uart.out();</div>
</div><!-- fragment --><p> Then an output stream is created for tracing through UART, and the necessary UART ISR is registered.</p>
<div class="fragment"><div class="line">    PublicDevice(MANAGER&amp; manager): PARENT{manager, DEVICE_ADDRESS, i2c::Mode&lt;MODE&gt;{}} {}</div>
</div><!-- fragment --><p> Any specificity of the tested I2C device is defined as a constant in the next code section. Note the definition of <code>DEVICE_ADDRESS</code> constant: this 7-bit I2C device address is shifted one bit left as an 8th bit will be added (I2C communication protocol) to define data direction for each transmission.</p>
<div class="fragment"><div class="line">    PublicDevice device{manager};</div>
</div><!-- fragment --><p> This is where we define a utility class to debug our I2C interface to the tested device. <code>PublicDevice</code> class does <b>nothing</b> but making all protected methods callable from <code>main()</code>, so that we can directly perform our code tests in <code>main()</code>, without thinking much about proper API design now.</p>
<div class="fragment"><div class="line">}</div>
</div><!-- fragment --><p> This utility method is automatically called back by FastArduino I2C library for every low-level I2C command; it is useful to debug communication issues with the target I2C device during tests.</p>
<div class="fragment"></div><!-- fragment --><p> This is the <code>main()</code> function where it all happens. First we initialize the MCU and the UART for tracing.</p>
<div class="fragment"></div><!-- fragment --><p> Here we simply initialize I2C function on the UNO.</p>
<div class="fragment"></div><!-- fragment --><p> We then declare the <code>device</code> variable that we will use for testing our I2C device.</p>
<p>Finally we start an infinite loop where we can call read/write methods on <code>device</code> in order to test the way to handle the target device.</p>
<h1>Defining the driver API based on device features </h1>
<p>At this level, you have already been able to debug how the device works and you have a good overview of what features you want to provide to developers (and to yourself as the first of all) who will want to use this device.</p>
<p>An easy way is to provide an API that maps every feature found in the datasheet to its dedicated method. This is what we would call a low-level API; that is the minimum your driver should provide.</p>
<p>Additionally <code>MyI2CDevice</code> might implement a higher level API, based on the low-level one, but this is not mandatory; actually, this is not even advised generally, as this high-level API might be implemented in a distinct class. Using a separate class for high-level API allows other developers to develop their own high-level API without having to use yours if it does not fit their needs.</p>
<p>It is often advised to add <code>begin()</code> and <code>end()</code> methods to <code>MyI2CDevice</code> when it makes sense. <code>begin()</code> would initialize the device before usage (most devices will require special setup before use).</p>
<h1>Implementing the driver API </h1>
<p>This step consists in implementing the API defined in the step before.</p>
<p>Typically every API method will be made of:</p><ul>
<li><code>write()</code> calls to the device</li>
<li><code>read()</code> calls to the device</li>
<li>various conversions or calculation before calling <code>write()</code> or after calling <code>read()</code></li>
</ul>
<p>Here is a concrete example from <code><a class="el" href="classdevices_1_1rtc_1_1_d_s1307.html" title="I2C device driver for the DS1307 RTC chip.">devices::rtc::DS1307</a></code>, another I2C device driver in FastArduino: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> get_datetime(tm&amp; datetime)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// send register address to read from (0)</span></div>
<div class="line">    <span class="comment">// read datetime at address 0</span></div>
<div class="line">    <span class="keywordflow">if</span> (write(DEVICE_ADDRESS, TIME_ADDRESS, i2c::BusConditions::START_NO_STOP) == <a class="code" href="namespacei2c_1_1_status.html#a64da02c9095e825b16389e29f86d4192">i2c::Status::OK</a></div>
<div class="line">        &amp;&amp; read(DEVICE_ADDRESS, datetime, i2c::BusConditions::REPEAT_START_STOP) == <a class="code" href="namespacei2c_1_1_status.html#a64da02c9095e825b16389e29f86d4192">i2c::Status::OK</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// convert DS1307 output (BCD) to integer type</span></div>
<div class="line">        datetime.tm_sec = <a class="code" href="namespaceutils.html#af5b3426ba48caf5ee96ed71fa8b7bb5e">utils::bcd_to_binary</a>(datetime.tm_sec);</div>
<div class="line">        datetime.tm_min = <a class="code" href="namespaceutils.html#af5b3426ba48caf5ee96ed71fa8b7bb5e">utils::bcd_to_binary</a>(datetime.tm_min);</div>
<div class="line">        datetime.tm_hour = <a class="code" href="namespaceutils.html#af5b3426ba48caf5ee96ed71fa8b7bb5e">utils::bcd_to_binary</a>(datetime.tm_hour);</div>
<div class="line">        datetime.tm_mday = <a class="code" href="namespaceutils.html#af5b3426ba48caf5ee96ed71fa8b7bb5e">utils::bcd_to_binary</a>(datetime.tm_mday);</div>
<div class="line">        datetime.tm_mon = <a class="code" href="namespaceutils.html#af5b3426ba48caf5ee96ed71fa8b7bb5e">utils::bcd_to_binary</a>(datetime.tm_mon);</div>
<div class="line">        datetime.tm_year = <a class="code" href="namespaceutils.html#af5b3426ba48caf5ee96ed71fa8b7bb5e">utils::bcd_to_binary</a>(datetime.tm_year);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that, besides one I2C transmission with one <code>write()</code> followed by one <code>read()</code>, most code here consists in converting each received piece of data to proper format (BCD to binary).</p>
<h1>The last mile: add driver to FastArduino project! </h1>
<p>Bravo! You successfully added FastArduino support, in your own project, for a specific I2C device!</p>
<p>The last mile would now consist in adding your valuable work to FastArduino library! You do not <em>have to</em>, of course, but this would be a good way to:</p><ul>
<li>thank other people who provided FastArduino open source library to you</li>
<li>feel part of the community</li>
<li>get feedback on your work, potentially allowing it to be further improved</li>
<li>share your work with the rest of the world</li>
</ul>
<p>However, like for a marathon, the last mile can be difficult! In order to run this last mile, you will have to:</p><ul>
<li>first accept FastArduino Apache License 2.0 for your contribution, or discuss with FastArduino owner for another one, if compatible</li>
<li>follow FastArduino coding guidelines: this might impose some code rewrite or reformatting</li>
<li>add API documentation with doxygen: this is mandatory for all <code>public</code> methods, and advised for <code>protected</code> ones.</li>
<li>add one (or more) usage example and integrate it in the <code>examples/i2c</code> directory; examples must be kept simple but still demonstrate the API usage; example circuits (connection pins) shall be described. These examples can be further used as "tests" before new releases of FastArduino.</li>
<li>optionally develop a tutorial for this device</li>
<li>prepare and propose a PR to FastArduino project</li>
</ul>
<p><b>Important condition</b>: in order to accept merging a PR to FastArduino, I must be able to check it by myself, hence I need to first have the new supported device available on my workbench; I will gladly buy one (or a few) if it is affordable and easy to find. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="aclassi2c_1_1_i2_c_device_html"><div class="ttname"><a href="classi2c_1_1_i2_c_device.html">i2c::I2CDevice&lt; MANAGER &gt;</a></div></div>
<div class="ttc" id="anamespaceserial_html"><div class="ttname"><a href="namespaceserial.html">serial</a></div><div class="ttdoc">Defines all API for UART features.</div><div class="ttdef"><b>Definition:</b> <a href="soft__uart_8h_source.html#l00083">soft_uart.h:84</a></div></div>
<div class="ttc" id="aclassstreams_1_1ostream_html"><div class="ttname"><a href="classstreams_1_1ostream.html">streams::ostream</a></div><div class="ttdoc">Output stream wrapper to provide formatted output API, a la C++.</div><div class="ttdef"><b>Definition:</b> <a href="streams_8h_source.html#l00060">streams.h:61</a></div></div>
<div class="ttc" id="anamespaceboard_html_a8541ca1f10a050c4356d6ccd76d9a907"><div class="ttname"><a href="namespaceboard.html#a8541ca1f10a050c4356d6ccd76d9a907">board::USART</a></div><div class="ttdeci">USART</div><div class="ttdoc">Defines all USART modules of target MCU.</div><div class="ttdef"><b>Definition:</b> <a href="empty_8h_source.html#l00104">empty.h:105</a></div></div>
<div class="ttc" id="anamespacei2c_html_ac2780f0139dbc26f4d83a426dad67e36"><div class="ttname"><a href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36">i2c::I2CMode</a></div><div class="ttdeci">I2CMode</div><div class="ttdoc">I2C available transmission modes.</div><div class="ttdef"><b>Definition:</b> <a href="i2c_8h_source.html#l00105">i2c.h:106</a></div></div>
<div class="ttc" id="anamespacei2c_1_1debug_html_aa73d62f49bbf5a9cd8ced80e467cefcc"><div class="ttname"><a href="namespacei2c_1_1debug.html#aa73d62f49bbf5a9cd8ced80e467cefcc">i2c::debug::DEBUG</a></div><div class="ttdeci">DEBUG</div><div class="ttdoc">Indicate what in I2C protocol shall be debugged.</div><div class="ttdef"><b>Definition:</b> <a href="i2c__debug_8h_source.html#l00054">i2c_debug.h:55</a></div></div>
<div class="ttc" id="anamespacei2c_1_1_status_html_a64da02c9095e825b16389e29f86d4192"><div class="ttname"><a href="namespacei2c_1_1_status.html#a64da02c9095e825b16389e29f86d4192">i2c::Status::OK</a></div><div class="ttdeci">constexpr const uint8_t OK</div><div class="ttdoc">Code indicating the last called method executed as expected without any issue.</div><div class="ttdef"><b>Definition:</b> <a href="i2c_8h_source.html#l00067">i2c.h:67</a></div></div>
<div class="ttc" id="anamespacestreams_html_a25bd12279d518b57e4fb97c533c17b22"><div class="ttname"><a href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">streams::endl</a></div><div class="ttdeci">void endl(FSTREAM &amp;stream)</div><div class="ttdoc">Manipulator for an output stream, which will insert a new-line character and flush the stream buffer.</div><div class="ttdef"><b>Definition:</b> <a href="streams_8h_source.html#l00722">streams.h:722</a></div></div>
<div class="ttc" id="anamespaceboard_html_a2529f85498783a75dc75c281e0b754d3"><div class="ttname"><a href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a></div><div class="ttdeci">static void init()</div><div class="ttdoc">Performs special initialization for the target MCU.</div><div class="ttdef"><b>Definition:</b> <a href="empty_8h_source.html#l00043">empty.h:43</a></div></div>
<div class="ttc" id="anamespacestreams_html_a91675bd61b31e7382e8655930606f62f"><div class="ttname"><a href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">streams::hex</a></div><div class="ttdeci">void hex(FSTREAM &amp;stream)</div><div class="ttdoc">Manipulator for an output or input stream, which will set the base, used to represent (output) or int...</div><div class="ttdef"><b>Definition:</b> <a href="ios_8h_source.html#l00774">ios.h:774</a></div></div>
<div class="ttc" id="auart_8h_html"><div class="ttname"><a href="uart_8h.html">uart.h</a></div><div class="ttdoc">Hardware serial API.</div></div>
<div class="ttc" id="anamespaceboard_html"><div class="ttname"><a href="namespaceboard.html">board</a></div><div class="ttdoc">Defines all types and constants specific to support a specific MCU target.</div><div class="ttdef"><b>Definition:</b> <a href="empty_8h_source.html#l00037">empty.h:38</a></div></div>
<div class="ttc" id="ai2c__device_8h_html"><div class="ttname"><a href="i2c__device_8h.html">i2c_device.h</a></div><div class="ttdoc">I2C Device API.</div></div>
<div class="ttc" id="atime_8h_html"><div class="ttname"><a href="time_8h.html">time.h</a></div><div class="ttdoc">Simple time utilities.</div></div>
<div class="ttc" id="aclassi2c_1_1debug_1_1_i2_c_debug_status_recorder_html"><div class="ttname"><a href="classi2c_1_1debug_1_1_i2_c_debug_status_recorder.html">i2c::debug::I2CDebugStatusRecorder</a></div><div class="ttdoc">Class recording I2C debug and status notifications for later output.</div><div class="ttdef"><b>Definition:</b> <a href="i2c__debug_8h_source.html#l00273">i2c_debug.h:275</a></div></div>
<div class="ttc" id="auart_8h_html_aa33c57bb6fa1e93177abb21fe8fecb10"><div class="ttname"><a href="uart_8h.html#aa33c57bb6fa1e93177abb21fe8fecb10">REGISTER_UATX_ISR</a></div><div class="ttdeci">#define REGISTER_UATX_ISR(UART_NUM)</div><div class="ttdoc">Register the necessary ISR (Interrupt Service Routine) for an serial::hard::UATX to work correctly.</div><div class="ttdef"><b>Definition:</b> <a href="uart_8h_source.html#l00037">uart.h:37</a></div></div>
<div class="ttc" id="aclassi2c_1_1_i2_c_sync_status_manager_html"><div class="ttname"><a href="classi2c_1_1_i2_c_sync_status_manager.html">i2c::I2CSyncStatusManager</a></div><div class="ttdoc">Synchronous I2C Manager for ATmega architecture wit status notification facility.</div><div class="ttdef"><b>Definition:</b> <a href="i2c__handler__atmega_8h_source.html#l01188">i2c_handler_atmega.h:1190</a></div></div>
<div class="ttc" id="aclassi2c_1_1status_1_1_i2_c_latest_status_holder_html"><div class="ttname"><a href="classi2c_1_1status_1_1_i2_c_latest_status_holder.html">i2c::status::I2CLatestStatusHolder</a></div><div class="ttdoc">Class holding the latest I2C status.</div><div class="ttdef"><b>Definition:</b> <a href="i2c__status_8h_source.html#l00158">i2c_status.h:159</a></div></div>
<div class="ttc" id="autilities_8h_html"><div class="ttname"><a href="utilities_8h.html">utilities.h</a></div><div class="ttdoc">General utilities API that have broad application in programs.</div></div>
<div class="ttc" id="anamespacestreams_html_adaf650921b3a5d448f8aac51dba924d2"><div class="ttname"><a href="namespacestreams.html#adaf650921b3a5d448f8aac51dba924d2">streams::dec</a></div><div class="ttdeci">void dec(FSTREAM &amp;stream)</div><div class="ttdoc">Manipulator for an output or input stream, which will set the base, used to represent (output) or int...</div><div class="ttdef"><b>Definition:</b> <a href="ios_8h_source.html#l00765">ios.h:765</a></div></div>
<div class="ttc" id="aclassi2c_1_1_i2_c_sync_status_debug_manager_html"><div class="ttname"><a href="classi2c_1_1_i2_c_sync_status_debug_manager.html">i2c::I2CSyncStatusDebugManager</a></div><div class="ttdoc">Synchronous I2C Manager for ATmega architecture with status notification and debug facility.</div><div class="ttdef"><b>Definition:</b> <a href="i2c__handler__atmega_8h_source.html#l01232">i2c_handler_atmega.h:1234</a></div></div>
<div class="ttc" id="anamespaceutils_html_af5b3426ba48caf5ee96ed71fa8b7bb5e"><div class="ttname"><a href="namespaceutils.html#af5b3426ba48caf5ee96ed71fa8b7bb5e">utils::bcd_to_binary</a></div><div class="ttdeci">uint8_t bcd_to_binary(uint8_t bcd)</div><div class="ttdoc">Convert Binary-coded decimal byte (each nibble is a digit from 0 to 9) into a natural byte.</div><div class="ttdef"><b>Definition:</b> <a href="utilities_8h_source.html#l00343">utilities.h:343</a></div></div>
<div class="ttc" id="ai2c__status_8h_html"><div class="ttname"><a href="i2c__status_8h.html">i2c_status.h</a></div><div class="ttdoc">I2C status hook utilities.</div></div>
<div class="ttc" id="ai2c__debug_8h_html"><div class="ttname"><a href="i2c__debug_8h.html">i2c_debug.h</a></div><div class="ttdoc">I2C debugging utilities (useful when implementing support for new devices).</div></div>
<div class="ttc" id="anamespacetime_html_af13fd17ddf6b751b8161691e608892b2"><div class="ttname"><a href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a></div><div class="ttdeci">void delay_ms(uint16_t ms) INLINE</div><div class="ttdoc">Delay program execution for the given amount of milliseconds.</div><div class="ttdef"><b>Definition:</b> <a href="time_8h_source.html#l00346">time.h:346</a></div></div>
<div class="ttc" id="anamespacei2c_1_1status_html_a8e07f8d34f9f155ed73d199716ec173f"><div class="ttname"><a href="namespacei2c_1_1status.html#a8e07f8d34f9f155ed73d199716ec173f">i2c::status::STATUS</a></div><div class="ttdeci">STATUS</div><div class="ttdoc">Indicate when status should be traced.</div><div class="ttdef"><b>Definition:</b> <a href="i2c__status_8h_source.html#l00046">i2c_status.h:47</a></div></div>
<div class="ttc" id="aflash_8h_html_a16c40764aaba0de309f5ff429c8bac15"><div class="ttname"><a href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a></div><div class="ttdeci">#define F(ptr)</div><div class="ttdoc">Force string constant to be stored as flash storage.</div><div class="ttdef"><b>Definition:</b> <a href="flash_8h_source.html#l00098">flash.h:98</a></div></div>
<div class="ttc" id="aclassstreams_1_1ios__base_html_a46cf9813c05c34ff93d8ff19eff1ea9f"><div class="ttname"><a href="classstreams_1_1ios__base.html#a46cf9813c05c34ff93d8ff19eff1ea9f">streams::ios_base::width</a></div><div class="ttdeci">void width(uint8_t width)</div><div class="ttdoc">Set minimum width used for displaying values.</div><div class="ttdef"><b>Definition:</b> <a href="ios_8h_source.html#l00390">ios.h:390</a></div></div>
<div class="ttc" id="anamespacei2c_html_ac2780f0139dbc26f4d83a426dad67e36a94e94133f4bdc1794c6b647b8ea134d0"><div class="ttname"><a href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36a94e94133f4bdc1794c6b647b8ea134d0">i2c::I2CMode::STANDARD</a></div><div class="ttdeci">@ STANDARD</div><div class="ttdoc">I2C Standard mode, less than 100KHz.</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
