//   Copyright 2016-2020 Jean-Francois Poilpret
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

/// @cond api

/**
 * @file
 * API to handle Real-Time Clock DS1307 I2C chip.
 */
#ifndef DS1307_H
#define DS1307_H

#include "../i2c_device.h"
#include "../utilities.h"

/**
 * Defines API for Real-Time Clock chips usage.
 */
namespace devices::rtc
{
	/** Days of the week. */
	enum class WeekDay : uint8_t
	{
		SUNDAY = 1,
		MONDAY,
		TUESDAY,
		WEDNESDAY,
		THURSDAY,
		FRIDAY,
		SATURDAY
	};

	/**
	 * The datetime structure used by the RTC API.
	 * This is inspired by C standard time.h header but was slightly adapted to
	 * fit DS1307 RTC chip.
	 * @sa DS1307::get_datetime()
	 * @sa DS1307::set_datetime()
	 */
	struct tm
	{
		uint8_t tm_sec;  /**< seconds after the minute - [ 0 to 59 ] */
		uint8_t tm_min;  /**< minutes after the hour - [ 0 to 59 ] */
		uint8_t tm_hour; /**< hours since midnight - [ 0 to 23 ] */
		WeekDay tm_wday; /**< days since Sunday - [ 1 to 7 ] */
		uint8_t tm_mday; /**< day of the month - [ 1 to 31 ] */
		uint8_t tm_mon;  /**< months since January - [ 1 to 12 ] */
		uint8_t tm_year; /**< years since 2000 */
	};

	/**
	 * The possible frequencies that can be generated by DS1307 RTC SQW/OUT pin.
	 * @sa DS1307::enable_output()
	 */
	enum class SquareWaveFrequency : uint8_t
	{
		FREQ_1HZ = 0x00,
		FREQ_4096HZ = 0x01,
		FREQ_8192HZ = 0x02,
		FREQ_32768HZ = 0x03
	};

	/**
	 * I2C device driver for the DS1307 RTC chip.
	 * Note that this chip only supports standard I2C mode (100 KHz).
	 */
	class DS1307 : public i2c::I2CDevice<i2c::I2CMode::STANDARD>
	{
	public:
		/**
		 * Create a new device driver for a DS1307 chip.
		 * @param manager reference to a suitable i2c::I2CManager for this device
		 */
		explicit DS1307(MANAGER& manager) : I2CDevice(manager) {}

		/**
		 * Change date and time of the RTC chip connected to this driver.
		 * @param datetime the new date/time to set on the RTC chip; all values 
		 * must be properly set and be correct, in particular, note that
		 * `tm::tm_wday` must be set correctly by yourself (the RTC chip does not
		 * calculate it itself).
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * shall be called for further information on the error.
		 */
		bool set_datetime(tm& datetime)
		{
			// 1st convert datetime for DS1307 (BCD)
			datetime.tm_sec = utils::binary_to_bcd(datetime.tm_sec);
			datetime.tm_min = utils::binary_to_bcd(datetime.tm_min);
			datetime.tm_hour = utils::binary_to_bcd(datetime.tm_hour);
			datetime.tm_mday = utils::binary_to_bcd(datetime.tm_mday);
			datetime.tm_mon = utils::binary_to_bcd(datetime.tm_mon);
			datetime.tm_year = utils::binary_to_bcd(datetime.tm_year);
			// send register address to write to (0)
			// send datetime at address 0
			return write(DEVICE_ADDRESS, TIME_ADDRESS, i2c::BusConditions::START_NO_STOP) == i2c::Status::OK
				   && write(DEVICE_ADDRESS, datetime, i2c::BusConditions::NO_START_STOP) == i2c::Status::OK;
		}

		/**
		 * Get the current date and time from the RTC chip.
		 * @param datetime a reference to a `tm` variable that will be filled with
		 * current date and time from the RTC chip
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * shall be called for further information on the error.
		 */
		bool get_datetime(tm& datetime)
		{
			// send register address to read from (0)
			// read datetime at address 0
			if (write(DEVICE_ADDRESS, TIME_ADDRESS, i2c::BusConditions::START_NO_STOP) == i2c::Status::OK
				&& read(DEVICE_ADDRESS, datetime, i2c::BusConditions::REPEAT_START_STOP) == i2c::Status::OK)
			{
				// convert DS1307 output (BCD) to integer type
				datetime.tm_sec = utils::bcd_to_binary(datetime.tm_sec);
				datetime.tm_min = utils::bcd_to_binary(datetime.tm_min);
				datetime.tm_hour = utils::bcd_to_binary(datetime.tm_hour);
				datetime.tm_mday = utils::bcd_to_binary(datetime.tm_mday);
				datetime.tm_mon = utils::bcd_to_binary(datetime.tm_mon);
				datetime.tm_year = utils::bcd_to_binary(datetime.tm_year);
				return true;
			}
			return false;
		}

		/**
		 * Disable the RTC oscillator, hence the time will not be updated anymore.
		 * If you want to re-enable the clockm you need to set a new date/time
		 * with `set_datetime()`.
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * @sa set_datetime()
		 */
		bool halt_clock()
		{
			// just write 0x80 at address 0
			return write(DEVICE_ADDRESS, TIME_ADDRESS, i2c::BusConditions::START_NO_STOP) == i2c::Status::OK
				   && write(DEVICE_ADDRESS, CLOCK_HALT, i2c::BusConditions::NO_START_STOP) == i2c::Status::OK;
		}

		/**
		 * Enable square wave output to the SQW/OUT pin of the RTC chip.
		 * @param frequency one of the supported RTC frequencies, defined in
		 * `SquareWaveFrequency` enum
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * @sa disable_output()
		 */
		bool enable_output(SquareWaveFrequency frequency = SquareWaveFrequency::FREQ_1HZ)
		{
			ControlRegister control;
			control.sqwe = 1;
			control.rs = uint8_t(frequency);
			return write(DEVICE_ADDRESS, CONTROL_ADDRESS, i2c::BusConditions::START_NO_STOP) == i2c::Status::OK
				   && write(DEVICE_ADDRESS, control, i2c::BusConditions::NO_START_STOP) == i2c::Status::OK;
		}

		/**
		 * Disable square wave output to the SQW/OUT pin of the RTC chip.
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * @sa enable_output()
		 */
		bool disable_output(bool output_value = false)
		{
			ControlRegister control;
			control.out = output_value;
			return write(DEVICE_ADDRESS, CONTROL_ADDRESS, i2c::BusConditions::START_NO_STOP) == i2c::Status::OK
				   && write(DEVICE_ADDRESS, control, i2c::BusConditions::NO_START_STOP) == i2c::Status::OK;
		}

		/**
		 * Get the size of the additional RAM size of the chip.
		 */
		static constexpr uint8_t ram_size()
		{
			return RAM_SIZE;
		}

		/**
		 * Set one cell of the chip internal RAM to the specified value.
		 * @param address the address of the cell to write, must be between
		 * `0` and `ram_size()`.
		 * @param data the value to put at @p address
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * @sa get_ram(uint8_t, uint8_t)
		 */
		bool set_ram(uint8_t address, uint8_t data)
		{
			address += RAM_START;
			if (address < RAM_END)
				return write(DEVICE_ADDRESS, address, i2c::BusConditions::START_NO_STOP) == i2c::Status::OK
					   && write(DEVICE_ADDRESS, data, i2c::BusConditions::NO_START_STOP) == i2c::Status::OK;
			else
				return false;
		}

		/**
		 * Get the value of one cell of the chip internal RAM.
		 * @param address the address of the cell to read, must be between
		 * `0` and `ram_size()`.
		 * @return the value read at @p address
		 * @sa set_ram(uint8_t, uint8_t)
		 */
		uint8_t get_ram(uint8_t address)
		{
			address += RAM_START;
			uint8_t data = 0;
			if (address < RAM_END)
			{
				write(DEVICE_ADDRESS, address, i2c::BusConditions::START_NO_STOP);
				read(DEVICE_ADDRESS, data, i2c::BusConditions::REPEAT_START_STOP);
			}
			return data;
		}

		/**
		 * Set several cells of the chip internal RAM to specified values.
		 * @param address the address of the first cell to write, must be between
		 * `0` and `ram_size()`.
		 * @param data pointer to a buffer containing the values to write
		 * @param size the number of bytes to be written; `address + size` must be
		 * less than `ram_size()`.
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * @sa get_ram(uint8_t, uint8_t*, uint8_t)
		 */
		bool set_ram(uint8_t address, const uint8_t* data, uint8_t size)
		{
			address += RAM_START;
			if ((address + size) <= RAM_END)
				return write(DEVICE_ADDRESS, address, i2c::BusConditions::START_NO_STOP) == i2c::Status::OK
					   && write(DEVICE_ADDRESS, data, size, i2c::BusConditions::NO_START_STOP) == i2c::Status::OK;
			else
				return false;
		}

		/**
		 * Get values of several cells from the chip internal RAM.
		 * @param address the address of the first cell to read, must be between
		 * `0` and `ram_size()`.
		 * @param data pointer to a buffer where read values will be copied
		 * @param size the number of bytes to read; `address + size` must be
		 * less than `ram_size()`.
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * @sa set_ram(uint8_t, const uint8_t*, uint8_t)
		 */
		bool get_ram(uint8_t address, uint8_t* data, uint8_t size)
		{
			address += RAM_START;
			if ((address + size) <= RAM_END)
				return write(DEVICE_ADDRESS, address, i2c::BusConditions::START_NO_STOP) == i2c::Status::OK
					   && read(DEVICE_ADDRESS, data, size, i2c::BusConditions::REPEAT_START_STOP) == i2c::Status::OK;
			else
				return false;
		}

		/**
		 * Write any type of data to the chip internal RAM.
		 * @tparam T the type of data to be written
		 * @param address the address where to write data, must be between
		 * `0` and `ram_size() - sizeof(T)`.
		 * @param data the actual data of type @p T, to be written
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * @sa get_ram(uint8_t, T&)
		 */
		template<typename T> bool set_ram(uint8_t address, const T& data)
		{
			return set_ram(address, (const uint8_t*) &data, sizeof(T));
		}

		/**
		 * Read any type of data from the chip internal RAM.
		 * Note that this method only copies bytes to a variable of some type, no
		 * constructor will be called; hence, it is preferrable to use only simple
		 * struct types.
		 * @tparam T the type of data to be read
		 * @param address the address where to find data to read, must be between
		 * `0` and `ram_size() - sizeof(T)`.
		 * @param data a reference to a variable that will be copied the read content
		 * @retval true if the operation succeeded
		 * @retval false if the operation failed; if so, `i2c::I2CManager.status()`
		 * @sa set_ram(uint8_t, const T&)
		 */
		template<typename T> bool get_ram(uint8_t address, T& data)
		{
			return get_ram(address, (uint8_t*) &data, sizeof(T));
		}

	private:
		static constexpr const uint8_t DEVICE_ADDRESS = 0x68 << 1;
		static constexpr const uint8_t TIME_ADDRESS = 0x00;
		static constexpr const uint8_t CLOCK_HALT = 0x80;
		static constexpr const uint8_t CONTROL_ADDRESS = 0x07;
		static constexpr const uint8_t RAM_START = 0x08;
		static constexpr const uint8_t RAM_END = 0x40;
		static constexpr const uint8_t RAM_SIZE = RAM_END - RAM_START;

		union ControlRegister
		{
			explicit ControlRegister(uint8_t data = 0) : data{data} {}

			uint8_t data;
			struct
			{
				uint8_t rs : 2;
				uint8_t res1 : 2;
				uint8_t sqwe : 1;
				uint8_t res2 : 2;
				uint8_t out : 1;
			};
		};
	};
}

#endif /* DS1307_H */
/// @endcond
